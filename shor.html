<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <title>Grover's Search Algorithm</title>
  <link rel="stylesheet" href="css/Serif/cmun-serif.css"/>
  <link rel="stylesheet" href="css/tufte.css"/>
  <link rel="stylesheet" href="css/grover-figures.css"/>
  <link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      showMathMenu: false,
      "HTML-CSS": {
        scale: 90
      },
      TeX: {
      Macros: {
        braket: ['{\\langle #1 \\rangle}', 1],
        Abs: ['\\left\\lvert #2 \\right\\rvert_{\\text{#1}}', 2, ""],
        bra: ['{\\left\\langle #1\\right|}',1], 
        ket: ['{\\left| #1\\right\\rangle}',1], 
      }}
    });
  </script>
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

  <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>

  <!-- Global D3 variables etc -->
  <script type="text/javascript"> 
    var n_bits = 3; // Number of qubits
  </script>

<body>

<div id = "tufte_container"><h1 id="shors-factoring-algorithm">Shor’s Factoring Algorithm</h1>
<p>Shor’s algorithm is an algorithm for finding the prime factors of a given integer, discovered by Peter Shor [<span class="citation">1</span>]. It is a particularly celebrated quantum algorithm, due largely to the relevance of the integer factorisation problem to our everyday lives - the majority of encryption systems used in finance and electronic communication are reliant on the presumed difficulty of finding the prime factors of some very large integers.</p>
<p>The way in which Shor’s algorithm works is dependent on some non-trivial results from number theory, which we’ll go over first. A full treatment is rather involved - see, for example, Appendix 4 of Nielsen and Chuang [<span class="citation">2</span>], for the full story.<span class="math">\(\newcommand{\Mod}[1]{\ (\text{mod}\ #1)}\)</span></p>
<h2 id="from-period-finding-to-factorisation">From Period-Finding to Factorisation</h2>
<p>Essentially, Shor’s algorithm relies on the following fact: <em>finding the prime factors of some number</em> <span class="math">\(N\)</span> <em>is easy if we can find the period of</em> <span class="math">\(f\)</span>, where:</p>
<p><span class="math">\[f(x)=a^x \Mod{N}\]</span></p>
<p>Where by the <em>period</em> we mean the number <span class="math">\(r\)</span> that satisfies <span class="math">\(f(x+r)=f(x)\)</span>, and where <span class="math">\(a\)</span> is some integer less than <span class="math">\(N\)</span>. <span class="math">\(f\)</span> is often known as the modular <sup>1</sup><span class="marginnote">1.  Modular arithmetic is a form of arithmetic for integers in which the number line wraps back around to 0 upon reaching a certain number. This is familiar from reading an analogue clock! For example, 5 hours after 10:00 is not 15:00, but is 3:00 - where we’ve got 3 from the remainder of 15 divided by 12. The convention is to write this kind of addition as follows: <span class="math">\[10 + 5 \Mod{12} = 3\]</span> Where the number after the <span class="math">\(\textrm{mod}\)</span> is the number at which the number line goes back to 0. </span> exponentiation function. Let’s consider why knowing its period is useful for the factorisation problem.</p>
<p>Clearly, there exist only <span class="math">\(N\)</span> numbers <span class="math">\(\text{mod}\ N\)</span>, so it follows that for some number <span class="math">\(x\)</span> there exists a <span class="math">\(y &gt; x\)</span> such that <span class="math">\(a^y=a^x \Mod{N}\)</span>, where <span class="math">\(a\)</span> is defined as before. So:</p>
<p><span class="math">\[a^x (a^{y-x} - 1) \Mod{N} = 0\]</span></p>
<p>Now we can write <span class="math">\(r = y - x\)</span> and, furthermore, we impose that <span class="math">\(a\)</span> shares no factors with <span class="math">\(N\)</span>. This latter fact clearly means <span class="math">\(a^x\)</span> also shares no factors with <span class="math">\(N\)</span>, and hence from the above it is easy to see that:</p>
<p><span class="math">\[a^r = 1 \Mod{N}\]</span></p>
<p>It follows from this that our function <span class="math">\(f(x)\)</span> has a period of the smallest value of <span class="math">\(r\)</span> that satisfies the above<sup>2</sup><span class="marginnote">2.  <span class="math">\(f(x)\)</span> is quite an unusual function and unlike, say, <span class="math">\(\sin(x)\)</span> or <span class="math">\(\cos(x)\)</span>, it’s not possible to tell its period by looking at a small portion of it. It takes shapes like this: <img src="modexp.png"/> It should be apparent that finding its period is not easy! </span>. But what does this have to do with the factors of <span class="math">\(N\)</span>? Define <span class="math">\(\alpha = a^{r/2} \Mod{N}\)</span>, and then write:</p>
<p><span class="math">\[\begin{align}
\alpha^2 &amp; = 1 \Mod{N} \\
\alpha^2 - 1 = (\alpha + 1)(\alpha - 1) &amp; = 0 \Mod{N}
\end{align}\]</span></p>
<p>So, one of <span class="math">\((\alpha \pm 1)\)</span> divides <span class="math">\(N\)</span>. It can be shown that we can write the greatest common divider of 2 integers <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, denoted <span class="math">\(\gcd(a,b)\)</span>, as <span class="math">\(ax + by\)</span> where <span class="math">\(x,y\)</span> are integers. Hence, if <span class="math">\(c\)</span> divides both <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, it also divides <span class="math">\(ax + by = \gcd(a,b)\)</span>. Factors of <span class="math">\(N\)</span> obviously will also divide whichever of <span class="math">\((\alpha \pm 1)\)</span> divides <span class="math">\(N\)</span>, and so calculating<sup>3</sup><span class="marginnote">3.  A very beautiful and efficient way to find the greatest common divisor of 2 integers is <em>Euclid’s algorithm</em>. This can be elegantly written as a recursion: <span class="math">\[\gcd(a,b) =
\begin{cases}
a &amp; b = 0 \\
\gcd(b, a \Mod{b}) &amp; b &gt; 0
\end{cases}\]</span> </span> <span class="math">\(\gcd(\alpha \pm 1, N)\)</span> gives us a non-trivial factor of <span class="math">\(N\)</span>.</p>
<p>Recalling that <span class="math">\(\alpha = a^{r/2} \Mod{N}\)</span>, then having found <span class="math">\(r\)</span> (by yet unspecified means) we require 2 pieces of good luck in order to use the above to find the factors of <span class="math">\(N\)</span>:</p>
<div class="list-container"><ul>
<li><span class="math">\(r\)</span> must be even - only then can we use <span class="math">\(a^{r/2}\)</span></li>
<li><span class="math">\(a^{r/2} \neq \pm 1 \Mod{N}\)</span> - these are the trivial solutions to <span class="math">\(\alpha^2 = 1 \Mod{N}\)</span></li>
</ul></div>
<p>Provided our luck holds (and if it doesn’t, we have to start again), this means that we can factor <span class="math">\(N\)</span> with repeated application of the following algorithm [<span class="citation">2</span>]:</p>
<div class="list-container"><ol style="list-style-type: decimal">
<li>Return 2 if <span class="math">\(N\)</span> is even</li>
<li>Determine whether <span class="math">\(N = a^b\)</span> for integers <span class="math">\(a \geq 1\)</span> and <span class="math">\(b \geq 2\)</span>, and if so then return <span class="math">\(a\)</span> as a factor<sup>4</sup><span class="marginnote">4. Note that earlier we required <span class="math">\(a^x\)</span> to share no factors with <span class="math">\(N\)</span>, so we have to eliminate these special cases</span>.</li>
<li>Choose a random integer <span class="math">\(a \in [1, N-1]\)</span>. Compute <span class="math">\(\gcd(a, N)\)</span> and if this is greater than 1 then return it.</li>
<li>Find <span class="math">\(r\)</span>, the period of <span class="math">\(f(x) = a^x \Mod{N}\)</span>.</li>
<li>Check whether <span class="math">\(r\)</span> is even and whether <span class="math">\(x^{r/2} \neq \pm 1 \Mod{N}\)</span>. If so, then calculate <span class="math">\(\gcd(x^{r/2} \pm 1, N)\)</span> and test to see which of these is a non-trivial factor, returning this factor. If not, then the algorithm has failed and must be tried again.</li>
</ol></div>
<p>It’s interesting to see how often our luck holds - if it’s less than 50% of the time then the algorithm isn’t very good. It can be shown, with some work, that:</p>
<p><span class="math">\[\Pr\left(r \text{ is even and } x^{r/2} \neq \pm 1 \Mod{N} \right) = 1 - \frac{1}{2^m}\]</span></p>
<p>Where <span class="math">\(m\)</span> is the number of prime factors of <span class="math">\(N\)</span>. This means that we succeed at least <span class="math">\(3/4\)</span> of the time!</p>
<p>This rather unexpected method for factorisation is all very well, but we’ve glossed over perhaps the most elusive step - finding the value of <span class="math">\(r\)</span>. Whilst quantum mechanics doesn’t seem to have very much in common with number theory, it certainly involves a lot of waves, and waves certainly involve a lot of periodicity: we will show that <span class="math">\(r\)</span> can be found efficiently by quantum computational methods.</p>
<div class="references">
<h2>References</h2>
<p>[1]P. Shor, “Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer,” <em>SIAM Rev.</em>, vol. 41, no. 2, pp. 303–332, Jan. 1999.</p>
<p>[2]M. A. Nielsen and I. L. Chuang, <em>Quantum Computation and Quantum Information</em>, 10th Anniversary Edition. Cambridge ; New York: Cambridge University Press, 2010.</p>
</div>
    <!-- Figure 1 -->
    <script type="text/javascript" src="js/fig1.js"></script>
    </div>

</body>
</html>
