<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <title>Shor's Factoring Algorithm</title>
  <link rel="stylesheet" href="css/Serif/cmun-serif.css"/>
  <link rel="stylesheet" href="css/tufte.css"/>
  <link rel="stylesheet" href="css/grover-figures.css"/>
  <link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      showMathMenu: false,
      "HTML-CSS": {
        scale: 90
      },
      TeX: {
      Macros: {
        braket: ['{\\langle #1 \\rangle}', 1],
        Abs: ['\\left\\lvert #2 \\right\\rvert_{\\text{#1}}', 2, ""],
        bra: ['{\\left\\langle #1\\right|}',1], 
        ket: ['{\\left| #1\\right\\rangle}',1], 
        Mod: ['{\\ (\\text{mod}\\ #1)}',1]
      }}
    });
  </script>
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

  <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>

  <!-- Global D3 variables etc -->
  <script type="text/javascript"> 
    var n_bits = 3; // Number of qubits
  </script>

<body>

<div id = "tufte_container">

<h1 id="shors-factoring-algorithm">Shor’s Factoring Algorithm</h1>

<p>Shor’s algorithm is an algorithm for finding the prime factors of a given integer, discovered by Peter Shor [<span class="citation">1</span>]. It is a particularly celebrated quantum algorithm, due largely to the relevance of the integer factorisation problem to our everyday lives - the majority of encryption systems used in finance and electronic communication are reliant on the presumed difficulty of finding the prime factors of some very large integers.</p>

<p>The way in which Shor’s algorithm works is dependent on some non-trivial results from number theory, which we’ll go over first. A full treatment of this is rather involved - see, for example, Appendix 4 of Nielsen and Chuang [<span class="citation">2</span>], for the full story. For a more in-depth treatment of the whole thing, then <a href="http://www.lassp.cornell.edu/mermin/qcomp/chap3.pdf">Mermin’s notes</a> are extremely good, as is Shor’s original paper [<span class="citation">1</span>] and, of course, <a href="http://en.wikipedia.org/wiki/Shor%27s_algorithm">Wikipedia</a>.</p>

<h2 id="from-period-finding-to-factorisation">From Period-Finding to Factorisation</h2>

<p>Essentially, Shor’s algorithm relies on the following fact:</p>

<blockquote>
<p><strong>Finding the factors of an integer <span class="math">\(N\)</span> is easy if we can find the period of the modular exponentiation function</strong> <span class="math">\(f(x)=a^x \Mod{N}\)</span></p>
</blockquote>

<p>Where by the <em>period</em> we mean the number <span class="math">\(r\)</span> that satisfies <span class="math">\(f(x+r)=f(x)\)</span>, where <span class="math">\(a\)</span> is some integer less than <span class="math">\(N\)</span> and where<span class="math">\(\Mod{N}\)</span> indicates that we are working in arithmetic modulo<sup>1</sup>

<span class="marginnote">
1.  Modular arithmetic is a form of arithmetic for integers in which the number line wraps back around to 0 upon reaching a certain number. This is familiar from reading an analogue clock! For example, 5 hours after 10:00 is not 15:00, but is 3:00 - where we’ve got 3 from the remainder of 15 divided by 12. The convention is to write this kind of addition as follows: <span class="math">\[10 + 5 \Mod{12} = 3\]</span> Where the number after the <span class="math">\(\textrm{mod}\)</span> is the number at which the number line goes back to 0.
</span>

<span class="math">\(N\)</span>. Let’s consider why knowing the period of <span class="math">\(f\)</span> is useful for the factorisation problem.</p>

<p>Clearly, there exist only <span class="math">\(N\)</span> numbers <span class="math">\(\text{mod}\ N\)</span>, so it follows that for some number <span class="math">\(x\)</span> there exists a <span class="math">\(y &gt; x\)</span> such that <span class="math">\(a^y=a^x \Mod{N}\)</span>, where <span class="math">\(a\)</span> is defined as before. So:</p>

<p><span class="math">\[a^x (a^{y-x} - 1) \Mod{N} = 0\]</span></p>

<p>Now we can write <span class="math">\(r = y - x\)</span> and, furthermore, we impose that <span class="math">\(a\)</span> shares no factors with <span class="math">\(N\)</span>. This latter fact clearly means <span class="math">\(a^x\)</span> also shares no factors with <span class="math">\(N\)</span>, and hence from the above it is easy to see that:</p>

<p><span class="math">\[a^r = 1 \Mod{N}\]</span></p>

<p>It follows from this that our function <span class="math">\(f(x)\)</span> has a period of the smallest value of <span class="math">\(r\)</span> that satisfies the above<sup>2</sup>

<span class="marginnote">2.  <span class="math">\(f(x)\)</span> is quite an unusual function and unlike, say, <span class="math">\(\sin(x)\)</span> or <span class="math">\(\cos(x)\)</span>, it’s not possible to tell its period by looking at a small portion of it. It takes shapes like this: <img src="images/modexp.png" style="display: block; margin: 1.5em auto; width: 90%;"/> It should be apparent that finding the period of this function is not easy!
</span>

. But what does this have to do with the factors of <span class="math">\(N\)</span>? Define <span class="math">\(\alpha = a^{r/2} \Mod{N}\)</span>, and then write:</p>
<p><span class="math">\[\begin{align}
\alpha^2 &amp; = 1 \Mod{N} \\
\alpha^2 - 1 = (\alpha &amp; + 1)(\alpha - 1) = 0 \Mod{N}
\end{align}\]</span></p>
<p>So, one of <span class="math">\((\alpha \pm 1)\)</span> divides <span class="math">\(N\)</span>. It can be shown that we can write the greatest common divider of 2 integers <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, denoted <span class="math">\(\gcd(a,b)\)</span>, as <span class="math">\(ax + by\)</span> where <span class="math">\(x,y\)</span> are integers. Hence, if <span class="math">\(c\)</span> divides both <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, it also divides <span class="math">\(ax + by = \gcd(a,b)\)</span>. Factors of <span class="math">\(N\)</span> obviously will also divide whichever of <span class="math">\((\alpha \pm 1)\)</span> divides <span class="math">\(N\)</span>, and so calculating<sup>3</sup><span class="marginnote">3.  A very beautiful and efficient way to find the greatest common divisor of 2 integers is <em>Euclid’s algorithm</em>. This can be elegantly written as a recursion: <span class="math">\[\gcd(a,b) =
\begin{cases}
a &amp; b = 0 \\
\gcd(b, a \Mod{b}) &amp; b &gt; 0
\end{cases}\]</span> Which requires a number of operations scaling quadratically in the number of digits in <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. </span> <span class="math">\(\gcd(\alpha \pm 1, N)\)</span> gives us a non-trivial factor of <span class="math">\(N\)</span>.</p>
<p>Recalling that <span class="math">\(\alpha = a^{r/2} \Mod{N}\)</span>, then having found <span class="math">\(r\)</span> (by yet unspecified means) we require 2 pieces of good luck in order to use the above to find the factors of <span class="math">\(N\)</span>:</p>
<div class="list-container"><ul>
<li><span class="math">\(r\)</span> must be even - only then can we use <span class="math">\(a^{r/2}\)</span></li>
<li><span class="math">\(a^{r/2} \neq \pm 1 \Mod{N}\)</span> - these are the trivial solutions to <span class="math">\(\alpha^2 = 1 \Mod{N}\)</span></li>
</ul></div>
<p>Provided our luck holds (and if it doesn’t, we have to start again), this means that we can factor <span class="math">\(N\)</span> with repeated application of the following algorithm [<span class="citation">2</span>]:</p>
<div class="list-container"><ol style="list-style-type: decimal">
<li>Return 2 if <span class="math">\(N\)</span> is even</li>
<li>Determine whether <span class="math">\(N = a^b\)</span> for integers <span class="math">\(a \geq 1\)</span> and <span class="math">\(b \geq 2\)</span>, and if so then return <span class="math">\(a\)</span> as a factor<sup>4</sup><span class="marginnote">4. Note that earlier we required <span class="math">\(a^x\)</span> to share no factors with <span class="math">\(N\)</span>, so we have to eliminate these special cases</span>.</li>
<li>Choose a random integer <span class="math">\(a \in [1, N-1]\)</span>. Compute <span class="math">\(\gcd(a, N)\)</span> and if this is greater than 1 then return it.</li>
<li>Find <span class="math">\(r\)</span>, the period of <span class="math">\(f(x) = a^x \Mod{N}\)</span>.</li>
<li>Check whether <span class="math">\(r\)</span> is even and whether <span class="math">\(x^{r/2} \neq \pm 1 \Mod{N}\)</span>. If so, then calculate <span class="math">\(\gcd(x^{r/2} \pm 1, N)\)</span> and test to see which of these is a non-trivial factor, returning this factor. If not, then the algorithm has failed and must be tried again.</li>
</ol></div>
<p>It’s interesting to see how often our luck holds - if it’s less than 50% of the time then the algorithm isn’t very good. It can be shown, with some work, that:</p>
<p><span class="math">\[\Pr\left(r \text{ is even and } x^{r/2} \neq \pm 1 \Mod{N} \right) = 1 - \frac{1}{2^m}\]</span></p>
<p>Where <span class="math">\(m\)</span> is the number of prime factors of <span class="math">\(N\)</span>. This means that we succeed at least half of the time!</p>
<p>This rather unexpected method for factorisation is all very well, but we’ve glossed over perhaps the most elusive step - finding the value of <span class="math">\(r\)</span>. Whilst quantum mechanics doesn’t seem to have very much in common with number theory, it certainly involves a lot of waves, and waves certainly involve a lot of periodicity: we will show that <span class="math">\(r\)</span> can be found efficiently by quantum computational methods.</p>
<h2 id="the-quantum-fourier-transform">The Quantum Fourier Transform</h2>
<p>A very familiar operation for physicists is the Fourier transform, defined (up to normalisation conventions<sup>5</sup><span class="marginnote">5. It’s worth noting here that, for whatever reason, quantum information theorists usually use a positive sign in the exponent for the Fourier transform and a negative for the inverse transform. This is opposite to what we usually come across in the rest of physics/maths.</span>) as:</p>
<p><span class="math">\[\hat{f}(\omega) = \int_{-\infty}^{\infty} f(x) \, e^{i \omega x} \ \text{d} x\]</span></p>
<p>For discrete <span class="math">\(x\)</span> - that is to say, for vectors of length <span class="math">\(Q\)</span> with values <span class="math">\(x_i\)</span> - we can define the related Discrete Fourier Transform (DFT):</p>
<p><span class="math">\[y_k = \frac{1}{\sqrt{Q}} \sum_{j = 0}^{Q - 1} x_j \, e^{2 \pi i j k / Q}\]</span></p>
<p>And a very similar Quantum Fourier Transform (QFT):</p>
<p><span class="math">\[\ket{j} \xrightarrow{QFT} \frac{1}{\sqrt{Q}} \sum_{k = 0}^{Q - 1} e^{2 \pi i j k / Q} \ket{k}\]</span></p>
<p>Where <span class="math">\(\ket{j}\)</span> and <span class="math">\(\ket{k}\)</span> are <span class="math">\(n\)</span>-qubit states expressed in binary notation<sup>6</sup><span class="marginnote">6.  We can write <span class="math">\(n\)</span>-qubit states using only one number: <span class="math">\[\ket{x} \equiv \ket{x_1 x_2 \cdots x_n}\]</span> where <span class="math">\[x = x_1 2^{n-1} + x_2 2^{n-2} + \cdots + x_n 2^0\]</span> For example, <span class="math">\(\ket{5} \equiv \ket{0101}\)</span>. The important thing here is to remember that some state <span class="math">\(\ket{x}\)</span> is <strong>not</strong> a state of a single qubit; it is a state of <span class="math">\(n\)</span> qubits. </span> and <span class="math">\(Q = 2^n\)</span>. As we know that complex numbers of the form <span class="math">\(e^{i \theta}\)</span> lie on the unit circle in the complex plane, we can see that the QFT takes some state <span class="math">\(\ket{j}\)</span> to a uniform superposition of states running from <span class="math">\(\ket{0}\)</span> to <span class="math">\(\ket{Q-1}\)</span>, but where these states have different phase factors, uniformly distributed with an angular distance between them of <span class="math">\(j/Q\)</span>. Bearing this in mind, the action of the QFT is illustrated below.</p>
<h3 id="finding-the-period-using-the-qft">Finding the Period Using the QFT</h3>
<p>The utility of the QFT is in the fact that its result has peaks at positions related to the period of the original coefficients. This is quite well-known (consider the Fourier transform’s ubiquity in spectral analysis) but is also easy to see. If we start out with:</p>
<p><span class="math">\[\begin{align}
\sum_x A(x) \ket{x} &amp; \xrightarrow{QFT} \sum_x B(x) \ket{x} \\
B(x) = \frac{1}{\sqrt{Q}} &amp; \sum_{j = 0}^{Q - 1} e^{2 \pi i j x / Q} A(j) \\
\end{align}\]</span></p>
<p>Then if <span class="math">\(A(x)\)</span> is periodic with period <span class="math">\(r\)</span> and we define <span class="math">\(R\)</span> as the nearest integer to <span class="math">\(Q / r\)</span>, we see that:</p>
<p><span class="math">\[\begin{align}
B(x) &amp; = \frac{1}{\sqrt{Q}} \sum_{m = 0}^{R - 1} \sum_{j = 0}^{Q - 1} e^{2 \pi i (j + m r) x / Q} A(j + m r) \\
&amp; = \frac{1}{\sqrt{R}} \frac{1}{\sqrt{Q}} \sum_{m = 0}^{R - 1} e^{2 \pi i m x / R} \sum_{j = 0}^{Q - 1} e^{2 \pi i j x / Q} A(j) \\
&amp; = \frac{\sqrt{r}}{Q} \left( \frac{1 - e^{2 \pi i x}}{1 - e^{2 \pi i x / R}} \right) \sum_{j = 0}^{Q - 1} e^{2 \pi i j x / Q} A(j)
\end{align}\]</span></p>
<p>In this last term, notice that as as <span class="math">\(x\)</span> approaches integer multiples of <span class="math">\(R\)</span>, the denominator in the brackets tends to 0 and hence <span class="math">\(B(x)\)</span> blows up: as we claimed, the QFT has peaks related to the period of the original coefficients, specifically at integer multiples of <span class="math">\(Q / r\)</span>.</p>

<p> It’s worth explicitly pointing out that this isn’t by itself very useful to us as we don’t actually know all the values of <span class="math">\(B(x)\)</span>; we just have a superposition of them so any measurement will give us <span class="math">\(B(x)\)</span> only for some specific value of <span class="math">\(x\)</span>. However, this is not an insurmountable obstacle, as we’ll see in the next section.</p>
<h2 id="the-continued-fraction-expansion">The Continued Fraction Expansion</h2>
<p>Through a bit of hand-waving, we suggested above that it will be possible for us to know something close to the value of an integer multiple of <span class="math">\(Q / r\)</span>. But how can we find <span class="math">\(r\)</span> from this?</p>
<p>It turns out (again, refer to [<span class="citation">2</span>]) that given a real and rational number <span class="math">\(x\)</span>, then if <span class="math">\[ \left| x - \frac{j}{r} \right| \leq \frac{1}{2 r^2} \]</span> then if we express <span class="math">\(x\)</span> as a continued fraction<sup>7</sup><span class="marginnote" style="margin-top: -130px;">7.  Continued fractions are a way of representing real numbers with only integers, in forms that look like: <span class="math">\[ x = a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \frac{1}{\ldots + \frac{1}{a_M}}}} \]</span> where the <span class="math">\(a_m\)</span> are integers. We can obtain them from, say, a usual fractional representation by an iterative process: we first take <span class="math">\(a_0 = \lfloor x \rfloor\)</span> as the integer part of <span class="math">\(x\)</span>, then find the reciprocal of the fractional part, then find the integer part of the fractional part and identify this as <span class="math">\(a_1\)</span>, and then repeat this procedure iteratively until the fractional part is 0. An example makes this clear: let <span class="math">\(x = 2.35 = 2 \frac{7}{20} \)</span>. Now <span class="math">\[\begin{align} x &amp; = 2 + \frac{7}{20} = 2 + \frac{1}{20/7} \\ &amp; = 2 + \frac{1}{2 + \frac{6}{7}} = 2 + \frac{1}{2 + \frac{1}{7/6}} \\ &amp; = 2 + \frac{1}{2 + \frac{1}{1 + \frac{1}{6}}} \end{align}\]</span> </span>, <span class="math">\(j/r\)</span> is a <em>convergent</em> of it - that is to say, a number obtained by taking the first <span class="math">\(n\)</span> terms of the fraction. Let’s say <span class="math">\(x\)</span> is an approximation to <span class="math">\(j/r\)</span> and that we know it to a precision of <span class="math">\(b\)</span> bits. Then simple arithmetic tells us that <span class="math">\[ \left| x - \frac{j}{r} \right| \leq \frac{1}{2^{b}} \]</span> so in order to exploit the continued fraction property we must have <span class="math">\(2^b \geq 2r^2\)</span>.</p>
<p>This is, for now, enough knowledge for us to define the period-finding algorithm for the modular exponentiation function and to look at its behaviour and its subtleties.</p>
<h2 id="the-period-finding-algorithm">The Period-Finding Algorithm</h2>
<p>We start off with some composite number <span class="math">\(N\)</span>, and allow ourselves access to 2 “registers” of <span class="math">\(n\)</span> qubits, choosing <span class="math">\(n\)</span> to satisfy <span class="math">\(N^2 \leq Q \leq 2 N^2\)</span> where <span class="math">\(Q = 2^n\)</span> as before. Define a unitary operator for calculating<sup>8</sup><span class="marginnote" style="margin-top: 40px">8.  The modular exponentiation function is not actually very easy to calculate. <span class="math">\(a^j\)</span> is potentially a <em>very</em> large number (requiring a lot of memory to be stored in a computer) and a naive calculation of the function requires a number of operations that scales linearly with the exponent <span class="math">\(j\)</span>. It turns out we can calculate the function in a way that uses less memory and scales with <span class="math">\(\log j\)</span>. We first write <span class="math">\(j\)</span> as a sum of powers of 2: <span class="math">\[ j = \sum_i c_i 2^i \]</span> And so we can write <span class="math">\(a^j\)</span> as: <span class="math">\[ a^j = a^{\sum_i c_i 2^i} = \prod_i \left( a^{2^i} \right)^{c_i} \]</span> Recalling that <span class="math">\[ [x \Mod{N}] \cdot [y \Mod{N}] = x \cdot y \Mod{N} \]</span> We can then write: <span class="math">\[ a^j \Mod{N} = \prod_i \left[ \left( a^{2^i} \right)^{c_i} \Mod{N} \right] \]</span> Which contains comparatively small numbers at each multiplication, thus saving memory. </span> the modular exponentiation function:</p>
<p><span class="math">\[ U_{ME} ( \ket{j} \ket{k} ) \rightarrow \ket{j} \ket{a^j \Mod{N}} \]</span></p>
<p>Where <span class="math">\(a\)</span> is an integer that satisfies the previously discussed requirement of sharing no factors with <span class="math">\(N\)</span>. Now we can define the period-finding algorithm:</p>
<div class="list-container"><ol style="list-style-type: decimal">
<li>Prepare the registers with all qubits in the ground state: <span class="math">\[\ket{\psi_1} = \ket{0}^{\otimes n} \ket{0}^{\otimes n}\]</span></li>
<li>Put the first register into a state of uniform superposition (ie apply <span class="math">\(H^{\otimes n}\)</span> where <span class="math">\(H\)</span> is the Hadamard gate). Then apply the modular exponentiation unitary to the combined registers. <span class="math">\[ \ket{\psi_2} = \frac{1}{\sqrt{Q}} \sum_{j = 0}^{Q - 1} \ket{j} \ket{a^j \Mod{N}} \]</span></li>
<li>Measure the 2nd register<sup>9</sup><span class="marginnote" style="margin-top: 25px">9. We can actually perform the measurement before or after the QFT; here we choose to do so before to get rid of unnecessary symbols in the derivation. Many authors - including Nielsen and Chuang - perform the measurement post-QFT</span>, obtaining some (random) state <span class="math">\(\ket{a^{j_0} \Mod{N}}\)</span>. Then the first register collapses to: <span class="math">\[ \ket{\psi_3} = \frac{1}{\sqrt{R}} \sum_{m = 0}^{R - 1} \ket{j_0 + m r} \]</span> Where, as before, <span class="math">\(r\)</span> is the period of the modular exponentiation function and <span class="math">\(R\)</span> is the nearest integer to <span class="math">\(Q / r\)</span>. The reason we get this is that, because <span class="math">\(a^j \Mod{N}\)</span> is periodic, there are <span class="math">\(R\)</span> points spaced at intervals of <span class="math">\(r\)</span> at which it takes the measured value.</li>
<li>Apply the QFT to the state, and rewrite in the same way as was done in the previous section. <span class="math">\[\begin{align} \ket{\psi_3} \xrightarrow{QFT} \ket{\psi_4} &amp; = \frac{1}{\sqrt{Q}} \frac{1}{\sqrt{R}} \sum_{k = 0}^{Q - 1} \sum_{m = 0}^{R - 1} e^{2 \pi i (j_0 + m r) k / Q} \ket{k} \\ &amp; = \frac{1}{\sqrt{QR}} \sum_{k = 0}^{Q - 1} e^{2 \pi i j_0 k / Q} \underbrace{ \left( \sum_{m = 0}^{R - 1} e^{2 \pi i m r k / Q} \right)}_{\alpha(k)} \ket{k} \\ &amp; = \frac{1}{\sqrt{QR}} \sum_{k = 0}^{Q - 1} \omega^k \alpha(k) \ket{k} \end{align}\]</span> Where <span class="math">\(\omega = e^{2 \pi i j_0 / Q}\)</span>, the powers of which all have a magnitude of 1, and so the probability of measuring some state <span class="math">\(k\)</span> is wholly dependent on <span class="math">\(\alpha(k)\)</span>.</li>
<li>Measure the first register. Let’s see how likely it is that we’ll measure a value of <span class="math">\(k\)</span> that is close to an integer multiple of <span class="math">\(Q / r\)</span>. Call this value <span class="math">\(\kappa = j Q / r + \epsilon\)</span>, where <span class="math">\(j\)</span> is an integer and <span class="math">\(\epsilon\)</span> is a small real number with magnitude <span class="math">\(\leq 1/2\)</span> that “makes up the difference” to the nearest integer. <span class="math">\[\begin{align} \Pr(\text{measure } \kappa) &amp; = \frac{1}{Q R} \left| \sum_{m = 0}^{R - 1} e^{2 \pi i m r (j Q / r + \epsilon) / Q} \right|^2 \\ &amp; = \frac{1}{Q R} \left| \sum_{m = 0}^{R - 1} e^{2 \pi i m r \epsilon / Q} \right|^2 \\ &amp; = \frac{1}{Q R} \frac{\sin^2 (\pi \epsilon R r / Q)}{\sin^2 (\pi \epsilon r / Q)} \\ &amp; \approx \frac{1}{Q R} \left( \frac{\sin(\pi\epsilon)}{\pi\epsilon r / Q} \right)^2 \\ &amp; = frac{1}{r}\left( \frac{\sin(\pi \epsilon)}{\pi\epsilon} \right)^2 \end{align}\]</span> Where the approximation comes from the fact that <span class="math">\(R\)</span> is <span class="math">\(Q / r\)</span> rounded to the nearest integer, and from the small angle approximation. As <span class="math">\(|\epsilon| \leq 1/2\)</span> we can then easily see that: <span class="math">\[\Pr(\text{measure } \kappa) \geq \frac{1}{r} \left( \frac{1}{\pi / 2} \right)^2 = \frac{4}{\pi^2 r}\]</span> So, as there are at least <span class="math">\(r - 1\)</span> integer multiples of <span class="math">\(Q / r\)</span> (ie this number of possible values of <span class="math">\(j\)</span>), for large <span class="math">\(r\)</span> we measure a <span class="math">\(k\)</span> close to an integer multiple of <span class="math">\(Q / r\)</span> at least <span class="math">\(4/\pi^2 \approx\)</span> 40% of the time!<sup>10</sup><span class="marginnote">10. An interesting case is when <span class="math">\(r\)</span> is itself a power of 2. In this case then of course <span class="math">\(Q / r\)</span> is an integer, and it can be shown that the probability of <span class="math">\(\kappa\)</span> being a multiple of it is 1! These values of <span class="math">\(r\)</span> occur for primes of the form <span class="math">\(2^j + 1\)</span> - “Fermat primes” - such as 15.</span></li>
<li>As we have chosen <span class="math">\(n\)</span> so that <span class="math">\(N^2 \leq 2^n \leq 2N^2\)</span> and given that <span class="math">\(r \leq N\)</span>, we know <span class="math">\(\kappa\)</span> to sufficient precision to use the continued fraction expansion to find some <span class="math">\(j^\prime/r^\prime = j/r\)</span>. As shown in the first section, we can check to see whether <span class="math">\(r^\prime = r\)</span> by testing to see if <span class="math">\(a^{r^\prime} \Mod{N} = 1\)</span>. If this is the case, we are done: we have found <span class="math">\(r\)</span>.<br /><br /> However, we might be unfortunate and find that <span class="math">\(j\)</span> and <span class="math">\(r\)</span> share a factor, meaning that <span class="math">\(r^\prime\)</span> is actually a <em>factor</em> of <span class="math">\(r\)</span>. We can try to get around this without starting again. If we assume that the common factor of <span class="math">\(j\)</span> and <span class="math">\(r\)</span> is small, then we can test a few small multiples of <span class="math">\(r^\prime\)</span> to see if they are in fact <span class="math">\(r\)</span>, which is classically quite easy to do.<br /><br /> Even more cleverly, we could perform 2 phase estimations thus obtaining <span class="math">\(r^\prime_1\)</span> and <span class="math">\(r^\prime_2\)</span>, and could then try their lowest common multiple as a candidate for <span class="math">\(r\)</span>.</li>
</ol></div>
<p>And so, using the properties of the QFT, we have found the period of the modular exponentiation function. Given the number-theoretic results of the first section, this means we can find the factors of <span class="math">\(N\)</span>.</p>
<div class="references">
<h2>References</h2>
<p>[1] P. Shor, “<a href="http://epubs.siam.org/doi/pdf/10.1137/S0036144598347011">Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer</a>” <em>SIAM Rev.</em>, vol. 41, no. 2, pp. 303–332, Jan. 1999.</p>
<p>[2] M. A. Nielsen and I. L. Chuang, <em>Quantum Computation and Quantum Information</em>, 10th Anniversary Edition. Cambridge ; New York: Cambridge University Press, 2010.</p>
</div>
</div>

</body>
</html>
